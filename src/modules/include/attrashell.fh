 !-----------------------------------------------------------------------------------------!
 ! This subroutine computes the V_elec contribution for a shell pair for each grid point   !
 ! It loops over each gridpoint, calls esp_1pdm and stores the value in esp_electronic()   !  
 ! This is - \sum_{mu nu} P_{mu nu} * V_{mu nu}                                            !
 ! See Eqn. A14 of Obara-Saika [J. Chem. Phys. 84, 3963 (1986)]                            !        
 ! First, calculates 〈 phi_mu | phi_nu 〉 for all mu and nu                               !
 ! Then, P_{mu nu} * 〈 phi_mu | 1/|r-C| | phi_nu 〉                                       !
 !-----------------------------------------------------------------------------------------!
#if defined (OEPROP)
subroutine esp_shell_pair(IIsh, JJsh, esp_electronic)
#elif defined (OEI)
subroutine attrashell(IIsh, JJsh)
#endif
   use quick_method_module, only: quick_method
   use quick_basis_module, only: quick_basis, attraxiao
   use quick_molspec_module, only: quick_molspec, xyz
   use quick_overlap_module, only: gpt, opf, overlap_core
   use quick_constants_module, only : Pi

#if defined (OEI)
   use quick_molspec_module, only: natom
#endif

   implicit none

   integer :: IIsh, JJsh, ips, jps, L, Maxm, NII2, NIJ1, NJJ2
   double precision :: a, b, Ax, Ay, Az, Bx, By, Bz, Cx, Cy, Cz, g, U
   double precision :: attra, const, constanttemp, PCsquare, Px, Py, Pz

#if defined (OEI)
   double precision :: Z
#endif

   double precision, dimension(0:20) :: aux
   double precision AA(3),BB(3),CC(3),PP(3)
   common /xiaoattra/attra,aux,AA,BB,CC,PP,g 
   double precision RA(3),RB(3),RP(3),inv_g,g_table(200), valopf

#if defined (OEPROP)
   integer :: igridpoint
   double precision, dimension(:), intent(inout) :: esp_electronic
#elif defined (OEI)
   integer :: iatom
#endif
  
   ! Related to positions of "QM" atoms
   Ax=xyz(1,quick_basis%katom(IIsh))
   Ay=xyz(2,quick_basis%katom(IIsh))
   Az=xyz(3,quick_basis%katom(IIsh))
 
   Bx=xyz(1,quick_basis%katom(JJsh))
   By=xyz(2,quick_basis%katom(JJsh))
   Bz=xyz(3,quick_basis%katom(JJsh))
 
   NII2=quick_basis%Qfinal(IIsh)
   NJJ2=quick_basis%Qfinal(JJsh)
   Maxm=NII2+NJJ2
            
   ! Calculation of V_elec starts here
   do ips=1,quick_basis%kprim(IIsh)
      a=quick_basis%gcexpo(ips,quick_basis%ksumtype(IIsh))
      do jps=1,quick_basis%kprim(JJsh)
         b=quick_basis%gcexpo(jps,quick_basis%ksumtype(JJsh))
 
         ! Screen one electron integrals
         valopf = opf(a, b, quick_basis%gccoeff(ips,quick_basis%ksumtype(IIsh)), &
         quick_basis%gccoeff(jps,quick_basis%ksumtype(JJsh)), Ax, Ay, Az, Bx, By, Bz)
 
         if(abs(valopf) .gt. quick_method%coreIntegralCutoff) then
 
           !Eqn 14 Obara-Saika 86
           call gpt(a,b,Ax,Ay,Az,Bx,By,Bz,Px,Py,Pz,0,g_table)
           g = a+b
           !Eqn 15 Obara-Saika 86
           inv_g = 1.0d0 / dble(g)
 
           ! Calculate first two terms of Obara & Saika Eqn A20
           constanttemp=dexp(-((a*b*((Ax - Bx)**2.d0 + (Ay - By)**2.d0 + (Az - Bz)**2.d0))*inv_g))
           const = overlap_core(a,b,0,0,0,0,0,0,Ax,Ay,Az,Bx,By,Bz,Px,Py,Pz,g_table) * 2.d0 * sqrt(g/Pi)*constanttemp
           
#if defined (OEPROP)
           ! Loops over external grid points/MM atoms
            do igridpoint=1,quick_molspec%nextpoint
              Cx=quick_molspec%extxyz(1,igridpoint)
              Cy=quick_molspec%extxyz(2,igridpoint)
              Cz=quick_molspec%extxyz(3,igridpoint)
#elif defined (OEI)
            !nextatom=number of external MM point charges. set to 0 if none used
            do iatom=1,natom+quick_molspec%nextatom
              if(iatom<=natom)then
                Cx=xyz(1,iatom)
                Cy=xyz(2,iatom)
                Cz=xyz(3,iatom)
                Z=-1.0d0*quick_molspec%chg(iatom)
              else
                Cx=quick_molspec%extxyz(1,iatom-natom)
                Cy=quick_molspec%extxyz(2,iatom-natom)
                Cz=quick_molspec%extxyz(3,iatom-natom)
                Z=-quick_molspec%extchg(iatom-natom)
              endif
#endif
                ! Calculate the last term of Obara--Saika Eqn A21
                PCsquare = (Px-Cx)**2 + (Py -Cy)**2 + (Pz -Cz)**2
                ! Compute Obara--Saika Eqn A21
                U = g* PCsquare
 
               ! Calculate the last term of Obara--Saika Eqn A20
               call FmT(Maxm,U,aux)
               ! Calculate all the auxilary integrals and store in attraxiao array
               do L = 0,maxm
#if defined (OEPROP)
                  ! sign (-1.0d0) is used to ensure the auxilary integrals are negative
                  aux(L) = -1.0d0*aux(L)*const
#elif defined (OEI)
                  aux(L) = aux(L)*const*Z
#endif
                  attraxiao(1,1,L)=aux(L)
               enddo
 
               NIJ1=10*NII2+NJJ2
#if defined (OEPROP)
               ! Call and get P_{mu nu} V_{mu nu} into esp_electronic( )
               call esp_1pdm(ips,jps,IIsh,JJsh,NIJ1,Ax,Ay,Az,Bx,By,Bz, &
                     Cx,Cy,Cz,Px,Py,Pz, esp_electronic(igridpoint))
#elif defined (OEI)
               call nuclearattra(ips,jps,IIsh,JJsh,NIJ1,Ax,Ay,Az,Bx,By,Bz, &
                     Cx,Cy,Cz,Px,Py,Pz)
#endif
            enddo

         endif
      enddo
   enddo
#if defined (OEPROP)
 end subroutine esp_shell_pair
#elif defined (OEI)
 end subroutine attrashell
#endif
